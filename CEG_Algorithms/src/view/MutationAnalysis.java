package view;

import Fourier.Mut;
import com.itextpdf.text.log.SysoLogger;
import graph.CEG;
import graph.Effect;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.filechooser.FileNameExtensionFilter;
import mutation.Mutant;
import mutation.MutantDetail;
import org.openide.util.Exceptions;
import test.TestInput;
import test.TestSet;

/**
 *
 * @author deniz.kavzak
 */
public class MutationAnalysis extends javax.swing.JFrame {

    //private File file;
    private static int id = 0;
    private File outFile;
    private CEG ceg;
    private TestSet testSet;
    private String methodName;
    //private ArrayList<Mutant> allMutants; //holds all the mutants that are created
    // private HashMap<String, ArrayList<String>> mutantsOfTypesString; //holds all the mutants as string for each fault type
    //private HashMap<String, ArrayList<Mutant>> mutantsOfTypes; //holds all the mutants for each fault type
    // private HashMap<String, Integer> totalMutants; //holds the total number of mutants for each fault type
    //private HashMap<String, Integer> mutationResult; //holds the number of detected faults for each fault type
    //private HashMap<Effect, ArrayList<Mutant>> mutantsOfEffect; //holds the related mutants for each effect node

    private Mut mut;
    
    /**
     * Creates new form MutationAnalysis
     */
    public MutationAnalysis(CEG ceg, String methodName, TestSet testSet, Mut mut) {
        this.ceg = ceg;
        this.testSet = testSet;
        //  mutantsOfTypesString = new HashMap<>();
        
        this.mut = mut;
        this.methodName = methodName;
       // mutantsOfTypes = new HashMap<>();
       // allMutants = new ArrayList<>();
       // mutationResult = new HashMap<>();
        //   totalMutants = new HashMap<>();
       // mutantsOfEffect = new HashMap<>();
        initComponents();

        this.setVisible(true);
        lblMethodName.setText(methodName);
        //fillAllMutants(); //mut a taşındı yapıp kaldırdık buradan
    }


    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        lstMutants = new javax.swing.JList<>();
        btnAnalysis = new javax.swing.JButton();
        lblMethodName = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel1 = new javax.swing.JLabel();
        btnExportMutation = new javax.swing.JButton();
        btnBack = new javax.swing.JButton();
        lblORF = new javax.swing.JLabel();
        lblENF = new javax.swing.JLabel();
        lblVNF = new javax.swing.JLabel();
        lblMVF = new javax.swing.JLabel();
        VRF = new javax.swing.JLabel();
        lblCCF = new javax.swing.JLabel();
        lblCDF = new javax.swing.JLabel();
        lblSA0 = new javax.swing.JLabel();
        lblSA1 = new javax.swing.JLabel();
        btnImportMutants = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle(org.openide.util.NbBundle.getMessage(MutationAnalysis.class, "MutationAnalysis.title")); // NOI18N

        jScrollPane1.setViewportView(lstMutants);

        org.openide.awt.Mnemonics.setLocalizedText(btnAnalysis, org.openide.util.NbBundle.getMessage(MutationAnalysis.class, "MutationAnalysis.btnAnalysis.text")); // NOI18N
        btnAnalysis.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnAnalysisActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(lblMethodName, org.openide.util.NbBundle.getMessage(MutationAnalysis.class, "MutationAnalysis.lblMethodName.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(jLabel2, org.openide.util.NbBundle.getMessage(MutationAnalysis.class, "MutationAnalysis.jLabel2.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(jLabel3, org.openide.util.NbBundle.getMessage(MutationAnalysis.class, "MutationAnalysis.jLabel3.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, org.openide.util.NbBundle.getMessage(MutationAnalysis.class, "MutationAnalysis.jLabel1.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(btnExportMutation, org.openide.util.NbBundle.getMessage(MutationAnalysis.class, "MutationAnalysis.btnExportMutation.text")); // NOI18N
        btnExportMutation.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnExportMutationActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(btnBack, org.openide.util.NbBundle.getMessage(MutationAnalysis.class, "MutationAnalysis.btnBack.text")); // NOI18N
        btnBack.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnBackActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(lblORF, org.openide.util.NbBundle.getMessage(MutationAnalysis.class, "MutationAnalysis.lblORF.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(lblENF, org.openide.util.NbBundle.getMessage(MutationAnalysis.class, "MutationAnalysis.lblENF.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(lblVNF, org.openide.util.NbBundle.getMessage(MutationAnalysis.class, "MutationAnalysis.lblVNF.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(lblMVF, org.openide.util.NbBundle.getMessage(MutationAnalysis.class, "MutationAnalysis.lblMVF.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(VRF, org.openide.util.NbBundle.getMessage(MutationAnalysis.class, "MutationAnalysis.VRF.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(lblCCF, org.openide.util.NbBundle.getMessage(MutationAnalysis.class, "MutationAnalysis.lblCCF.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(lblCDF, org.openide.util.NbBundle.getMessage(MutationAnalysis.class, "MutationAnalysis.lblCDF.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(lblSA0, org.openide.util.NbBundle.getMessage(MutationAnalysis.class, "MutationAnalysis.lblSA0.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(lblSA1, org.openide.util.NbBundle.getMessage(MutationAnalysis.class, "MutationAnalysis.lblSA1.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(btnImportMutants, org.openide.util.NbBundle.getMessage(MutationAnalysis.class, "MutationAnalysis.btnImportMutants.text")); // NOI18N
        btnImportMutants.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnImportMutantsActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(43, 43, 43)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(lblORF)
                            .addComponent(VRF))
                        .addGap(29, 29, 29)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(lblENF)
                            .addComponent(lblCCF))
                        .addGap(31, 31, 31)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(lblVNF)
                            .addComponent(lblCDF))
                        .addGap(26, 26, 26)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(lblMVF)
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addComponent(lblSA0)
                                .addGap(18, 18, 18)
                                .addComponent(lblSA1)))
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 285, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel3)
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 475, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addGroup(jPanel1Layout.createSequentialGroup()
                                        .addComponent(btnAnalysis)
                                        .addGap(142, 142, 142)
                                        .addComponent(btnImportMutants)))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(btnExportMutation)
                                .addGap(18, 18, 18)
                                .addComponent(btnBack)))
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jLabel2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(lblMethodName, javax.swing.GroupLayout.PREFERRED_SIZE, 183, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(754, 754, 754))))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(20, 20, 20)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(lblMethodName, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jLabel2, javax.swing.GroupLayout.DEFAULT_SIZE, 23, Short.MAX_VALUE))
                .addGap(18, 18, 18)
                .addComponent(jLabel3)
                .addGap(13, 13, 13)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(lblORF)
                    .addComponent(lblENF)
                    .addComponent(lblVNF)
                    .addComponent(lblMVF))
                .addGap(18, 18, 18)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(VRF)
                    .addComponent(lblCCF)
                    .addComponent(lblCDF)
                    .addComponent(lblSA0)
                    .addComponent(lblSA1))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 195, Short.MAX_VALUE)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(btnExportMutation)
                    .addComponent(btnBack))
                .addContainerGap())
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addGap(5, 5, 5)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(btnAnalysis)
                    .addComponent(btnImportMutants))
                .addGap(13, 13, 13)
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 181, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, 799, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 45, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(24, 24, 24)
                .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void btnBackActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnBackActionPerformed
        this.setVisible(false);
    }//GEN-LAST:event_btnBackActionPerformed
/*
    private boolean isDetected(String mutant, Effect effect) {

        String exp = effect.getRelation().getExpression();
        String modifiedExp = exp;
        String modifiedMutant = mutant;

        for (TestInput ti : testSet.getTestSet()) {
            modifiedExp = exp;
            modifiedMutant = mutant;

            for (String s : ti.getTestInput().keySet()) {
                while (modifiedExp.contains(s + " ")) {
                    String check = s + " ";
                    modifiedExp = modifiedExp.replace(check, ti.getTestInput().get(s).toString().toLowerCase() + " ");
                }

                while (modifiedMutant.contains(s + " ")) {
                    String check = s + " ";
                    modifiedMutant = modifiedMutant.replace(check, ti.getTestInput().get(s).toString().toLowerCase() + " ");
                }
            }

            while (modifiedMutant.contains("C")) {
                int beg = modifiedMutant.indexOf("C");
                int end = modifiedMutant.indexOf(" ", beg);
                String check = modifiedMutant.substring(beg, end);

                modifiedMutant = modifiedMutant.replace(check, "false");
            }
            
            while (modifiedExp.contains("C")) {
                int beg = modifiedExp.indexOf("C");
                int end = modifiedExp.indexOf(" ", beg);
                String check = modifiedExp.substring(beg, end);

                modifiedExp = modifiedExp.replace(check, "false");
            }
            //return false;
            if (!modifiedMutant.contains("C") && !modifiedExp.contains("C")) {
                try {
                    BooleanExpression be = BooleanExpression.readLeftToRight(modifiedExp);
                    BooleanExpression be2 = BooleanExpression.readLeftToRight(modifiedMutant);

                    if (be.booleanValue() != be2.booleanValue()) {
                        return true;
                    }

                } catch (MalformedBooleanException ex) {
                    Exceptions.printStackTrace(ex);
                }
            }
        }

        return false;
    }
*/
    private void btnAnalysisActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnAnalysisActionPerformed

      /*  for (String s : mut.getMutantsOfTypes().keySet()) {
            int i = 0;
            for (Mutant m : mut.getMutantsOfTypes().get(s)) {
                Effect effect = m.getEffect();

                for (String mutantAsString : m.getMutants()) {
                    if (mut.isDetected(mutantAsString, effect,testSet)) {
                        i++;
                    }
                }
            }
            mut.getMutationResult().put(s, i);
        }
        */ //bunu en son commentledim
        
        /*
        for (Effect effect : mutantsOfEffect.keySet()) {

            for (Mutant m : mutantsOfEffect.get(effect)) {
                int i = 0;

                for (String s : m.getMutants()) {
                    if (isDetected(s, effect)) {
                        i++;
                    }
                }

                if (mutationResult.keySet().contains(convertToAbbr(m))) {
                    int j = mutationResult.get(convertToAbbr(m)) + i;
                    mutationResult.put(convertToAbbr(m), j);
                } else {
                    mutationResult.put(convertToAbbr(m), i);
                }
            }
        }
         */
        
        //mut.getMutantAnalysisResultsMutantTypes(testSet);
        
        //clear previous mutation results
        mut.getNoOfMutantsOfTypes().clear();
        mut.getMutationResult().clear();
        
        try {
            mut.getMutantAnalysisResultsForAllEffects(testSet, 1);
        } catch (IOException ex) {
            Exceptions.printStackTrace(ex);
        }
        
        String[] tests = new String[mut.getMutationResult().keySet().size()];
        int i = 0;

        int overall = 0;
        
        for (String s : mut.getMutationResult().keySet()) {
            String element = "";

           /* int all = 0;

            for (Mutant m : mut.getMutantsOfTypes().get(s)) {
                for (String st : m.getMutants()) {
                    all++;
                }
            }

            element += s + ": " + mut.getMutationResult().get(s) + " / " + all + " = " 
                    + ((double) mut.getMutationResult().get(s) / (double) all);*/
            overall += mut.getMutationResult().get(s);
            System.out.println("Mut result: "+mut.getMutationResult().get(s));
            System.out.println("Mut of types: "+mut.getNoOfMutantsOfTypes().get(s));
            System.out.println("The S result: "+s);
            element += s + ": " + mut.getMutationResult().get(s) + " / " + mut.getNoOfMutantsOfTypes().get(s) + " = "
                    + ((double) mut.getMutationResult().get(s) / (double) mut.getNoOfMutantsOfTypes().get(s));
            tests[i] = element;
            i++;
        }
        
        int allmutants = 0;
        for(String s : mut.getNoOfMutantsOfTypes().keySet()){
            allmutants += mut.getNoOfMutantsOfTypes().get(s);
        }
        
        //System.out.println(overall + " / " + allmutants + " = " +(double)overall/(double)allmutants);
        lstMutants.setListData(tests);
        
        if(methodName.equals("Fourier") || methodName.equals("Fourier_4Faults")){
            System.out.println(mut.killerTests);
            int co = 0;
            for(TestInput ti: testSet.getEliminatedTestSet()){
                if(ti.killer){
                    co++;
                }
            }
            System.out.println("Killers " + co);
        }
    }//GEN-LAST:event_btnAnalysisActionPerformed

   /* private String convertToAbbr(Mutant m) {
        String faultType = null;
        if (m instanceof ClauseConjunction) {
            faultType = "CCF";
        } else if (m instanceof ClauseDisjunction) {
            faultType = "CDF";
        } else if (m instanceof ExpressionNegation) {
            faultType = "ENF";
        } else if (m instanceof MissingVariable) {
            faultType = "MVF";
        } else if (m instanceof OperatorReference) {
            faultType = "ORF";
        } else if (m instanceof StuckAt0) {
            faultType = "SA0";
        } else if (m instanceof StuckAt1) {
            faultType = "SA1";
        } else if (m instanceof VariableNegation) {
            faultType = "VNF";
        } else if (m instanceof VariableReference) {
            faultType = "VRF";
        }

        return faultType;
    }
*/
    private void btnExportMutationActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnExportMutationActionPerformed
        if (mut.getMutationResult().keySet() != null) {

            JFileChooser fileChooser = new JFileChooser();
            File workingDirectory = new File(System.getProperty("user.dir"));
            fileChooser.setCurrentDirectory(workingDirectory);
            fileChooser.setFileFilter(new FileNameExtensionFilter("xml file", "xml"));
            int returnVal = fileChooser.showSaveDialog(jPanel1);

            if (returnVal == JFileChooser.APPROVE_OPTION) {
                // What to do with the file, e.g. display it in a TextArea
                outFile = fileChooser.getSelectedFile();

                BufferedWriter bf;
                try {
                    bf = new BufferedWriter(new FileWriter(outFile));

                    for (String s : mut.getMutationResult().keySet()) {
                        //System.out.println(ti);

                        int all = 0;

                        for (Mutant m : mut.getMutantsOfTypes().get(s)) {
                            for (String st : m.getMutants()) {
                                all++;
                            }
                        }

                        String element = s + ": " + mut.getMutationResult().get(s) + " / " + all + " = " + ((double) mut.getMutationResult().get(s) / (double) all);

                        bf.write(element);
                        bf.newLine();
                    }

                    bf.close();

                } catch (IOException e1) {
                    // TODO Auto-generated catch block
                    e1.printStackTrace();
                }

            } else {
                JOptionPane.showMessageDialog(jPanel1, "Error saving file! ");
            }

        } else {
            JOptionPane.showMessageDialog(jPanel1, "Do the Mutation Analysis first! ");
        }
    }//GEN-LAST:event_btnExportMutationActionPerformed

    private void btnImportMutantsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnImportMutantsActionPerformed
        
        JFileChooser fileChooser = new JFileChooser();
        File workingDirectory = new File(System.getProperty("user.dir"));
        fileChooser.setCurrentDirectory(workingDirectory);
        //fileChooser.setFileFilter(new FileNameExtensionFilter("graphml file", "graphml"));
        int returnVal = fileChooser.showOpenDialog(jPanel1);
        Set<MutantDetail> mutants = new HashSet<>();
        
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            // What to do with the file, e.g. display it in a TextArea
            File file = fileChooser.getSelectedFile();
            
            try {
                BufferedReader br = new BufferedReader(new FileReader(file));
                
                String line = br.readLine();
                
                while(line!=null){
                    String[] parts = line.split(",");
                    mutants.add(new MutantDetail(ceg.getEffectNode(parts[0].trim()), parts[1].trim(), parts[2].trim()));
                    line = br.readLine();                    
                }                
                br.close();
                
            } catch (FileNotFoundException ex) {
                Exceptions.printStackTrace(ex);
            } catch (IOException ex) {
                Exceptions.printStackTrace(ex);
            }

        } else {
            JOptionPane.showMessageDialog(jPanel1, "Error opening file! ");
        }

        mut.analysisOfImportedMutants(mutants, testSet);
        
        
    }//GEN-LAST:event_btnImportMutantsActionPerformed
/*
    public void fillAllMutants() {

        for (Effect effect : ceg.getEffectNodes()) {

            ArrayList<Mutant> effectMutants = new ArrayList<>();

            effectMutants.add(new ClauseConjunction(id++, effect));
            effectMutants.add(new ClauseDisjunction(id++, effect));
            effectMutants.add(new ExpressionNegation(id++, effect));
            effectMutants.add(new MissingVariable(id++, effect));
            effectMutants.add(new OperatorReference(id++, effect));
            effectMutants.add(new StuckAt0(id++, effect));
            effectMutants.add(new StuckAt1(id++, effect));
            effectMutants.add(new VariableNegation(id++, effect));
            effectMutants.add(new VariableReference(id++, effect));

            mutantsOfEffect.put(effect, effectMutants);

            allMutants.addAll(effectMutants);
        }
*/
        //System.out.println("no of all mutants: " + allMutants.size());
        /*for (Mutant m : allMutants) {

            String faultType = convertToAbbr(m);
            // System.out.println("fault type: " + faultType);
            if (mutantsOfTypesString.keySet().contains(faultType)) {
                ArrayList<String> created = mutantsOfTypesString.get(faultType);
                // System.out.println("created size : " + created.size());
                if (!m.getMutants().isEmpty()) {
                    created.addAll(m.getMutants());
                    mutantsOfTypesString.put(faultType, created);
                }
            } else if (!m.getMutants().isEmpty()) {
                mutantsOfTypesString.put(faultType, m.getMutants());
            }

            //System.out.println("size of type: " + mutantsOfTypes.get(faultType).size());
        }
         */
        /*
        for (Mutant m : allMutants) {

            String faultType = convertToAbbr(m);
            // System.out.println("fault type: " + faultType);
            if (mutantsOfTypes.keySet().contains(faultType)) {
                ArrayList<Mutant> created = mutantsOfTypes.get(faultType);
                // System.out.println("created size : " + created.size());
                created.add(m);
                mutantsOfTypes.put(faultType, created);

            } else {
                ArrayList<Mutant> created = new ArrayList<>();
                created.add(m);
                mutantsOfTypes.put(faultType, created);
            }
            //System.out.println("size of type: " + mutantsOfTypes.get(faultType).size());
        }

        //for (String s : mutantsOfTypes.keySet()) {
        //  totalMutants.put(s, mutantsOfTypes.get(s).size());
        //}
    }
*/
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel VRF;
    private javax.swing.JButton btnAnalysis;
    private javax.swing.JButton btnBack;
    private javax.swing.JButton btnExportMutation;
    private javax.swing.JButton btnImportMutants;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JLabel lblCCF;
    private javax.swing.JLabel lblCDF;
    private javax.swing.JLabel lblENF;
    private javax.swing.JLabel lblMVF;
    private javax.swing.JLabel lblMethodName;
    private javax.swing.JLabel lblORF;
    private javax.swing.JLabel lblSA0;
    private javax.swing.JLabel lblSA1;
    private javax.swing.JLabel lblVNF;
    private javax.swing.JList<String> lstMutants;
    // End of variables declaration//GEN-END:variables
}
